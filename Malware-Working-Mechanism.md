obscuring: che giấu 
Obfuscation: làm rối, xáo trộn 

Malware techniques: encrypt Obfuscation pack 

encrypt 
Obfuscation 
anti-debug
pack 
bonet 



## PE File:

- The most common formats are:
  - ELF(Executable and Linkable Format ) on *nix: Executable and Linkable Format 
  - PE on Windows: Portable Executable
  - Mach-O on OS X


Câu hỏi: Tại sao chúng ta quan tâm đến chi tiết của định dạng tệp PE? 
<br> Trả lời:
  - Biết đc các phần trong file thực thi, biết cách chtrinh chạy
  - Biết cách chèn code vào ntn để thực thi mã virus trong khi làm cho tệp PE trông giống như nó nhìn bình thường. 
  - Phat hiện mã độc, tìm ra các vi-rút được ngụy trang tốt. 
  - Dead space là vị trí hoàn hảo để ẩn vi-rút – vi-rút CIH tự phá vỡ thành các bộ phận và ẩn trong không gian chết giữa các phần PE.

Có thể chèn code madoc vào?
+ các section sẵn có (vd Relocation Information - thường ít đc sdung và khi chen vao sẽ ko gay anh huong nhieu)
+ thêm mới section và chèn code vào.
+ phần alignment giữa các section 

<br>

https://cppdeveloper.com/c-nang-cao/phan-biet-static-libraries-va-shared-libaries/#:~:text=Shared%20Libraries%20c%C3%B2n%20g%E1%BB%8Di%20l%C3%A0,executable%20c%E1%BB%A7a%20application%20l%C3%BAc%20runtime.

https://www.thegioididong.com/hoi-dap/file-dll-la-gi-cach-hoat-dong-nhu-the-nao-tai-sao-thieu-1366289

![image](https://user-images.githubusercontent.com/62002485/175452146-951b003e-1c43-4596-af23-28f9ed8b4380.png)
![image](https://user-images.githubusercontent.com/62002485/175452666-4dcf214f-7eff-40f4-bda1-beba30520b19.png)
![image](https://user-images.githubusercontent.com/62002485/175452841-ec071e28-e230-4c6a-ba6c-9cd3e6ee9b75.png)
![image](https://user-images.githubusercontent.com/62002485/175453685-7a792476-f568-4bf6-b718-0f61731c5fad.png)

<br>

### PE là định dạng riêng của Win32. Hầu hết các file thực thi trên Win32 đều thuộc dạng PE (Trừ các tập tin VxDs và các file DLL(Dynamic Linking Library) 16 bít).
![image](https://user-images.githubusercontent.com/62002485/175454255-277e46e2-898e-4528-8710-1a0f23d922fd.png)

![image](https://user-images.githubusercontent.com/62002485/167558510-1a334d13-f0b5-42c9-9f63-f67d670cedb6.png)

![image](https://user-images.githubusercontent.com/62002485/167558529-1448a3be-9dec-45b8-ae1f-8ed74909c971.png)

- `DOS MZ header` (64byte đầu): Vùng này được dùng  trong trường hợp chương trình chạy trên nền DOS, hệ điều hành DOS nhận biết đây là một file thực thi hợp lệ và sẽ thực thi nội dung trong phần DOS stub. DOS Header là một cấu trúc được định nghĩa trong file windows.inc hoặc winnt.h. Cấu trúc này gồm 19 thành phần, với 1 số trường cần lưu ý như:
  - Trường e_magic trong DOS header chứa Magic number mang giá trị 0x5A4D(“MZ”) viết tắt của ng sáng tạo ra hdh MZ DOS là Mark Zbikowsky, là signature của file PE, Giá trị này đánh dấu một DOS Header hợp lệ và được phép thực thi tiếp.
  - Trường e_lfanew: là một DWORD nằm ở cuối cùng của DOS Header, là trường chứa offset của PE Header so với vị trí đầu file(Con trỏ trỏ tới PE header)

![image](https://user-images.githubusercontent.com/62002485/175491495-e406d676-2598-440d-bfb4-6b7b0bcbd7d5.png)
![image](https://user-images.githubusercontent.com/62002485/175486508-07259123-688f-4021-9225-3cb3e097bc9d.png)

- `PE Header`: bao gồm các thông tin cần thiết cho quá trình loader load file lên bộ nhớ. Cấu trúc này gồm 3 phần được định nghĩa trong windows.inc:

  ![image](https://user-images.githubusercontent.com/62002485/175507844-288af772-1027-46ba-adbf-32c6f87899f1.png)

  - Signature: là 1 DWORD bắt đầu PE Header chứa chữ ký "PE": 50h, 45h (0x4550)
  - FileHeader (20 bytes tiếp theo) với 1 số trường cần lưu ý như:
  
    ![image](https://user-images.githubusercontent.com/62002485/175510397-363347a3-70fc-42bc-9dbd-c7cdadb4a5f6.png)
    - NumberOfSections: chứa số section của file. Nếu muốn thêm/xoá section trong PE file, ta cần thay đổi tương ứng trường này.
    - Machine: Cái file này sẽ đc biên dịch trên kiến trúc máy tính nào (vd AMD, Intel386)

  - OptionalHeader (224 bytes tiếp theo) với 1 số trường cần lưu ý như:
  
     ![image](https://user-images.githubusercontent.com/62002485/175508473-f3571ff4-a5f7-4f07-bbf4-0af7ceda0daa.png)
    - AddressOfEntryPoint (RVA): địa chỉ ảo tương đối của câu lệnh đầu tiên sẽ được thực thi. Nếu muốn chương trình bắt đầu từ một địa chỉ khác (để thực thi câu lệnh với mục đích khác) thì cần thay đổi địa chỉ này về địa chỉ tương đối của câu lệnh muốn thực thi.
    - ImageBase: Địa chỉ mà file PE ưu tiên được nạp lên trên bộ nhớ, cộng thêm RVA sẽ được địa chỉ EntryPoint thực sự.
    - SectionAlignment: Phần liên kết các section trong bộ nhớ, tức là một section luôn luôn được bắt đầu bằng bội số của sectionAlignment. Ví dụ: sectionAlignment là 1000h, section đầu tiên bắt đầu ở vị trí 401000h và kích thước là 10h, section tiếp theo sẽ bắt đầu tại địa chỉ 402000h.
    - FileAlignment: Phần liên kết các section trong file. Tương tự như SectionAlignment nhưng áp dụng với file.
    - SizeOfImage: Toàn bộ kích thước PE file trong bộ nhớ, là tổng của tất cả các headers và sections được liên kết tới SectionAlignment.
    - SizeOfHeaders: Kích thước của tất cả headers và section table, bằng kích thước file trừ đi tổng kích thước của các section trong file.
    - DataDirectory: là một mảng gồm 16 struct IMAGE_DATA_DIRECTORY 
    
    ![image](https://user-images.githubusercontent.com/62002485/175513239-d6cf6577-3024-4600-a871-e1b8a37365ac.png)
    ![image](https://user-images.githubusercontent.com/62002485/175513159-c20730b4-524d-46fe-962f-204948787fdc.png)
    
 -  `Section Table`: gồm một mảng các struct IMAGE_SECTION_HEADER, mỗi phần tử struct chứa thông tin về một section trong PE file. Cấu trúc này được định nghĩa trong file windows.inc như hình dưới đây với 1 số trường cần lưu ý như:
 ![image](https://user-images.githubusercontent.com/62002485/175513523-717673dd-bb32-4867-8e04-59e7d29cb324.png)
    - VirtualSize: Kích thước thật sự của dữ liệu trên section tính theo byte, giá trị này có thể nhỏ hơn kích thước trên ổ đĩa (SizeOfRawData)
    - VirtualAddress: RVA của section, là giá trị để ánh xạ khi section được load lên bộ nhớ
    - SizeOfRawData: Kích thước section data trên ổ đĩa
    - PointerToRawData: là offset từ vị trí đầu file tới section data.
    - Characteristics: đặc tính của section: thực thi, dữ liệu khởi tạo …
    
    ![image](https://user-images.githubusercontent.com/62002485/175547790-3488985e-68f4-4cc1-a018-4894e9f73971.png)

<br>

- `Cấu trúc PE có thể gồm nhiều section`, trong đó tối thiểu cần 2 section: data và code. Một số section thông dụng hay được gặp ở các chương trình:
  - Executable Code Section, có tên là `.text` (MicroSoft) hoc là `CODE` (Borland), chứa code thực thi.
  - Data Sections, có những tên như `.data`, `.bss`, `.rdata`  (MicroSoft) hay `DATA` (Borland): .data (đã khỏi tạo) và .bss chứa dl đọc/ghi và biến toàn cục ; .rdata chứa dl chỉ đọc, đôi khi chứa import/export information.
  - Resources Section, có tên là `.rsrc`chứa tài nguyên được sử dụng bởi tệp thực thi như icons, dialogs, menus, strings,...
  - Export Data Section, có tên là `.edata`, nếu có chứa thông tin export, nếu không có thông tin export chứa trong .rdata
  - Import Data Section. có tên là `.idata`, nếu có chứa thông tin import, nếu không có thông tin import chứa trong .rdata
  - Debug Information Section, có tên là `.debug`
  
  ![image](https://user-images.githubusercontent.com/62002485/175483321-6f5add5e-f68a-4dff-a36d-ce6a9ae54b3b.png)
      
![image](https://user-images.githubusercontent.com/62002485/175547233-e7373200-30e3-411f-a66b-3dc54760189f.png)
![image](https://user-images.githubusercontent.com/62002485/175547267-408026b3-bc95-4a1d-a370-8e19d8b52772.png)

![image](https://user-images.githubusercontent.com/62002485/175547665-33025333-261d-4529-a5bf-c9673cee3120.png)
![image](https://user-images.githubusercontent.com/62002485/175547698-00dc58b1-9851-43c0-91ae-f3375703f16d.png)
![image](https://user-images.githubusercontent.com/62002485/175548376-b03ae7f4-4965-453b-b586-fd9fb509e95d.png)


  
  <br>
  
  
- Infector Pseudocode:
  - Mở tệp để đọc và ghi
  - Trích xuất thông tin tệp PE
  - Tìm code cave có kích thước phù hợp
  - Điều chỉnh shellcode cho ứng dụng mục tiêu
  - Thêm bất kỳ dữ liệu bổ sung nào để mã shellcode hoạt động
  -  Đưa mã shellcode vào ứng dụng
  - Sửa đổi điểm bắt đầu của ứng dụng thành điểm bắt đầu của shellcode

<br>

## Phân loại các loại mã độc phổ biến 
https://viblo.asia/p/phan-loai-ma-doc-hien-nay-LzD5da7zKjY


<br>

  
 ## Virus:
 
- Virus máy tính hay còn gọi là vi rút để chỉ những đoạn mã chương trình được thiết kế để xâm nhập vào máy tính, phá hoại máy tính, dữ liệu nhằm mục đích lấy cắp thông tin => máy chậm, xuat hien quảng cáo, tự bật cam…
 
 ![image](https://user-images.githubusercontent.com/62002485/167562376-75b2d644-69f3-4b79-9b5b-4c056f49467a.png)
 
- Cách phòng virus: Sử dụng tường lửa, cập nhật bản vá lỗi hệ điều hành, phần mềm chống virus, đóng băng hệ thống(Đóng băng ổ cứng là phương pháp chống ghi các dữ liệu lên phân vùng ổ cứng được đóng băng, có nghĩa là sau khi bạn thực hiện đóng băng thành công thì mọi thao tác như cài đặt phần mềm - copy dữ liệu - chỉnh sửa file - tinh chỉnh hệ thống v.v... trên phân vùng được đóng băng sẽ trở về trạng thái như mới (lúc bạn đóng băng) sau khi thực hiện bạn Restart lại máy tính.).

<br>

## File Infection Techniques:

Từ một file ban đầu với các chức năng bình thường, attacker chèn đoạn mã độc virus vào có khả năng tự thực thi, thực hiện 1 số hành động nguy hại đến máy nạn nhân. Khi kích hoạt file bị nhiễm đầu tiên lập tức lan truyền sang file khác. Lây nhiễm mã độc hay cụ thể hơn ở đây là lây nhiễm virus vào 1 tập tin thực thi đó là việc làm kích hoạt 1 bản sao của virus vào một tập tin khác.

<br>

Mục tiêu lây nhiễm tệp cơ bản/ Virus phải đảm bảo:
  - Cho phép thực thi mã vi-rút
  - Tính tàng hình:
    - Bảo tồn kích thước tệp gốc
    - Bảo tồn chức năng tệp gốc - ẩn khỏi người dùng
    - Giả vờ là mã bình thường - ẩn khỏi phần mềm diệt vi rút, máy quét

<br>

Các tệp thực thi (* .EXE, * .COM, * .BAT, v.v.) thường là mục tiêu của vi rút
+ Việc thực thi một tệp bị nhiễm thường gây ra sự sao chép của vi-rút vào các tệp khác
+ Phần mềm chống vi rút thế hệ đầu tiên
phụ thuộc vào việc theo dõi kích thước tệp
    
<br>

Các kỹ thuật lây nhiễm tệp thực thi có thể được phân loại rộng rãi bằng cách `xác định đoạn mã vi-rút được đặt ở đâu, vị trí nào trong tệp`.

### 1. Ghi đè phá hủy tại vào phần đầu file - Beginning of the File with Destructive Overwrite
- Hai phương pháp chính:
  - Thay thế tệp * .exe bằng virus * .exe
  - Chỉ ghi đè phần đầu của một * .exe
- Phát hiện: 
  - File * .exe đã mất hoàn toàn chức năng của nó, vì vậy
  người dùng nhận thấy rằng có điều gì đó không ổn
  - Phần mềm chống vi rút dễ dàng tìm thấy vi rút ngay tại
  đầu của tập tin và kích thước tệp bị thay đổi

- Khử nhiễm bằng cách `khôi phục tệp từ bản sao lưu`

![image](https://user-images.githubusercontent.com/62002485/167559413-95813476-1a10-450b-a94a-ebf1e38c205a.png)

### 2. Ghi đè phá hủy vào vị trí ngẫu nhiên - Random Location in the File with Destructive Overwrite
- Virus ghi đè tại một vị trí ngẫu nhiên trong tệp * .exe.
- Phát hiện: Phần mềm chống vi-rút bây giờ phải tìm kiếm toàn bộ tệp
để tìm thấy nó; luồng chương trình có thể chuyển sang virus trong quá trình thực thi hoặc không hoặc chương tình sẽ bị crash.

- Khử nhiễm bằng cách `khôi phục tệp từ bản sao lưu`

![image](https://user-images.githubusercontent.com/62002485/167559717-0033a718-e58a-48a0-917f-8fe4d406bea3.png)

### 3. Appending Viruses:

- Nối Virus vào cuối File và thay đổi Entry Point hoặc sử dụng lệnh jump được ghi đè trên một vài byte đầu tiên của phần bắt đầu code thực thi để nhảy đến địa chỉ vi-rút. Các hướng dẫn các lưu trong virus, khi virus chấm dứt nó sẽ nhảy về vị trí chương trình ban đầu để các chức năng ứng dụng được giữ nguyên.

- Phổ biến là các tệp .COM của DOS

- Phát hiện: Phần mềm chống vi rút kiểm tra PE file headers, kích thước, entry point, code được thực thi tại entrypoint và dễ dàng phát hiện.

- Khử nhiễm bằng cách xóa section đáng ngờ, khôi phục entrypoint hoặc các byte bị ghi đè bởi lệnh jump. 

![image](https://user-images.githubusercontent.com/62002485/167559977-7dae9308-8abd-403e-bed6-73a1121c4068.png)

<br>

### 4. Cavity Viruses:

- Chèn vi-rút vào cấc không gian trong một tệp chứa đầy các số 0 hoặc khoảng trống ASCII, các lệnh NOP hoặc kí tự NULL byte và thay đổi Entry Point hoặc sử dụng lệnh jump được ghi đè trên một vài byte đầu tiên của phần bắt đầu code thực thi để nhảy đến địa chỉ vi-rút.
- A fractionated cavity virus: vi rút có thể được phân ra thành nhiều mảnh, phân phối vô nhiều khoảng trống khác nhau và kết nối bằng lệnh jump.
- Phát hiện: Phần mềm chống vi rút kiểm tra entry point, code được thực thi tại entrypoint và dễ dàng phát hiện lệnh jump.
![image](https://user-images.githubusercontent.com/62002485/167560344-1aec5ca5-5c2e-4054-b0c8-d783522c32a9.png)

<br>

### 5. Compressing Viruses
- Mã ứng dụng sẽ được nén và mã vi rút cộng với mã trình giải nén sẽ được chèn vào không gian đã tiết kiệm được từ việc nén mã ứng dụng.
- Có thể giữ cho kích thước tệp không thay đổi
- Thậm chí có thể không thay đổi điểm vào!
- Phát hiện: quét hệ thống để hổ trợ thêm cho các chương trình chống vi-rút nền, sử dụng cơ sở dữ liệu các virus code pattern chứa các lệnh đặc trưng để phát hiện ra decompressor code.
- Khử nhiễm bằng cách: file backup hoặc thông thường sẽ có 1 số thuật toán phổ biến, dựa vào signature để phát hiện ra chúng và dùng decompresser tương ứng để giải nén mã ứng dụng, xóa phần code virus và descompresser thay vào phần code vừa mới khôi phục.

![image](https://user-images.githubusercontent.com/62002485/167561211-4e79fac1-45a9-4071-9bec-a59e339674a5.png)

<br><br>

<i> Ba loại EPO virus sau đây sẽ có chung cách phát hiện là: kiểm tra .reloc section để phát hiện các code patterns như saving state, tricky jumps, ...</i>

### 6. Entry-Point Obscuring (EPO) Viruses (Call-Hijacking Viruses)

- Vi-rút Entry-Point Obscuring (EPO) che đi entry point của chính nó bằng cách tìm một lệnh call trong tệp PE nhắm mục tiêu và "chiếm quyền điều khiển" lệnh call đó thay đổi thành một lệnh gọi đến mã vi rút.
- Lưu địa chỉ lệnh gọi ban dầu để sau khi hoàn tất quá trình thực thi virus sẽ nhảy đến.
- Có thể giữ cho kích thước tệp không thay đổi tận dụng phần .reloc (ở định dạng PE cung cấp thông tin được sử dụng nếu chương trình phải được di chuyển lại trong quá trình thực thi, tức là được tải lại ở một điểm tải khác vì hệ thống phải chống phân mảnh bộ nhớ hoặc một số lý do khác)
- Làm thế nào virus có thể tìm thấy một function call? => Kiểm tra binary opcodes để tìm ra các call opcode.

![image](https://user-images.githubusercontent.com/62002485/167561600-beaca631-a555-4e8c-9990-8cfdb6853248.png)
  
 <br>
 
 ### 7. Import Table-replacing EPO Virus
 
- IAT (import address table) là bảng con trỏ đại chỉ hàm ghi lại các API (application program interface) mà ứng dụng người dùng đang sử dụng, các địa chỉ đó sẽ được thay đổi thành địa chỉ Virus, đòng thời sau khi thực thi virus khôi phục lại IAT để API được bảo toàn và duy trì tính ẩn.

 ![image](https://user-images.githubusercontent.com/62002485/167561917-1162a8be-bc1b-4f73-b371-8230f7120ece.png)

<br>

 ### 8. Semi-EPO: Unknown Entry Points:
  
- Định dạng Windows PE có một entry point khác ngoài main entry point  - thread local storage (TLS) entry points 
- Windows loader tìm kiếm các TLS entry point và thực thi nó đầu tiên trước cả main entry point
- Vi rút có thể thay đổi TLS entry point để trỏ tới mã vi rút
- Ví dụ: W32 / Chiton
  


<br>
  
## Worm:
 
- Sâu máy tính là một chương trình máy tính chứa phần mềm độc hại độc lập tự sao chép để lây lan sang các máy tính khác(thường là qua hệ thống thư điện tử). Nó thường sử dụng mạng máy tính để tự lây lan(khác biệt lớn nhất giữa sâu và virus), dựa vào các lỗi bảo mật trên máy tính mục tiêu để truy cập.

- Phân loại dựa vào 4 tiêu chí: 
     - Target Discovery: Phương pháp chọn mục tiêu  
     - Carrier: Cách lan truyền từ mục tiêu này đến mục tiêu khác 
     - Activation: Cơ chế kích hoạt sâu ở máy nạn nhân
     - Payload: Chức năng của sâu

![image](https://user-images.githubusercontent.com/62002485/175766985-30488371-fb75-40fb-a29c-5650a8812f19.png)

### Target Discovery: 
   - Phương pháp chọn mục tiêu  thường là chọn random ip hoặc tuần tự (thường sẽ chọn random vì tính lây lan nhanh rộng hơn và trùng lặp it hơn) 
   - Phương pháp tối ưu hóa:
     - Ưu tiên cho địa chỉ cục bộ: Cùng một hệ điều hành và các ứng dụng trong mạng con
     - Dựa vào thông tin bên thứ 3
       <br> VD: cần tấn công web chính phủ -> search gg để tìm thông tin các ip trang web chính phủ để giới hạn phạm vi ip cần tấn công.
     - Permutation scanning - Quét hoán vị: sử dụng điều phối phân tán để quét hệu quả hơn 
       <br> VD: chia không gian địa chỉ ip ra để tránh sự trùng lặp khi lây nhiễm, một máy chỉ đc phân công lây nhiễm một số máy khác 
     - Bandwidth-limited scanning: Không chờ đợi phản hồi 
     - Sử dụng danh sách mục tiêu được tạo trước vd hit-list
     - Thụ động: chờ các nạn nhân tiềm năng liên hệ với sâu (Ví dụ: trình duyệt chưa được vá) và sau đó lây nhiễm cho khách truy cập trong quá trình tương tác.
    
### Carrier: Cách lan truyền từ mục tiêu này đến mục tiêu khác 
   - Tự vận chuyên (Self-Carried Carrier): Tự gửi nó như một phần của quá trình lây nhiễm. Trong gói tin tấn công có kích hoạt sâu và tạo phiên bản sâu mới, sâu đi qua trong quá tình tấn công.
   - Kênh thứ hai (Second Channel) : Yêu cầu một kênh giao tiếp phụ để kết thúc quá trình lây nhiễm. Trong trường hợp này, sâu chỉ gửi một đoạn mã độc hại nhỏ đến mục tiêu
      - Ví dụ Blaster: kênh chính là RPC; kênh phụ là TFTP
      - VD: Khi lây nhiễm trên 1 máy, ik đến web server ftp tải về lây nhiễm.
   - Được nhúng (Embedded):
      - Tự gửi như một phần của kênh giao tiếp thông thường, thêm vào hoặc thay thế các thông báo bình thường (ví dụ: request web)
      - Thường được giun thụ động sử dụng
      - Tương đối lén lút


### Activation: Cơ chế kích hoạt sâu ở máy nạn nhân:
  - Kích hoạt con người: Loại sâu này sẽ hoạt động nếu người dùng thực hiện bản sao cục bộ của sâu. 
  - Kích hoạt dựa trên hoạt động của con người: Được kích hoạt khi người dùng thực hiện một số hoạt động thường không liên quan đến sâu (Ví dụ: đặt lại máy, đăng nhập)
  - Kích hoạt quy trình theo lịch trình: sâu tự kích hoạt thông qua các quy trình hệ thống đã lên lịch.
  - Tự kích hoạt: Bắt đầu thực thi bằng cách khai thác các lỗ hổng trong các dịch vụ luôn bật và sẵn có

### Payload:
  Mã độc thường Điều khiển từ xa, ddos, mã hóa dữ liệu, ăn cắp thông tin cá nhân. tống tiến.

Ngăn chặn sâu máy tính:
   - Luôn luôn bật tường lửa (Firewall): Hãy kiểm tra tình trạng của Firewall trong Control Panel để đảm bảo luôn ở chế độ bật (On).
   - Hãy luôn cập nhật hệ điều hành thông qua Windows Update và các bản cập nhật bảo mật được Microsoft cung cấp hàng tháng. 
   - Sử dụng các phần mềm phòng chống virus của các hãng có tên tuổi.
   - Không sử dụng các mật khẩu đơn giản, đặc biệt khi bạn truy cập vào các mạng máy tính hay Internet. 
   - Xem xét cẩn thận trước khi mở một file đính kém hay click chuột vào một đường link trong email cũng như cân nhắc trước khi đồng ý nhận một file chuyển qua mạng, 
   nên sử dụng các chức năng Scan virus của hòm thư trước khi mở file.

<br>

## Ransomware:

Ransomware là phần mềm tống tiền, nó là tên gọi chung của 1 dạng phần mềm độc hại - Malware, có "tác dụng" chính là ngăn chặn người dùng truy cập và sử dụng hệ thống máy tính hoặc các file tài liệu của họ (chủ yếu phát hiện trên hệ điều hành Windows). Các biến thể Malware dạng này thường đưa ra các thông điệp cho nạn nhân rằng họ phải nộp 1 khoản tiền kha khá vào tài khoản của hacker nếu muốn lấy lại dữ liệu, thông tin cá nhân hoặc đơn giản nhất là truy cập được vào máy tính của họ. Hầu hết các phần mềm Ransomware đều chiếm quyền và mã hóa toàn bộ thông tin của nạn nhân mà nó tìm được (thường gọi là Cryptolocker), còn một số loại Ransomware khác lại dùng TOR để giấu, ẩn đi các gói dữ liệu C&C trên máy tính (tên khác là CTB Locker).

<br>

## Bonet:

- Botnet là một mạng các máy tính được điều khiển từ xa bởi tin tặc.
Botnet được sử dụng bởi tin tặc để phát tán ransomware sang máy tính xách tay, điện thoại, máy tính bảng, máy tính, v.v... Chúng có thể không bị phát hiện và bạn thậm chí không biết thiết bị của mình có phải là một phần của botnet hay không. 

- Ở đây, một tên tội phạm mạng thực hiện vai trò của một “botmaster” sử dụng virus Trojan để xâm phạm bảo mật của một số máy tính và kết nối chúng vào mạng vì mục đích xấu. Mỗi máy tính trên mạng hoạt động như một “bot”, và được kẻ xấu kiểm soát để lây truyền malware, spam hoặc nội dung độc hại nhằm khởi động cuộc tấn công. Botnet còn được gọi là đội quân zombie vì các máy tính liên quan đang được điều khiển bởi một người khác không phải chủ sở hữu của chúng.

<br>

## Encrypted Viruses:

![image](https://user-images.githubusercontent.com/62002485/167563647-7d7d3b97-eaf8-4418-a7d9-ba14590f414c.png)






