## PE File:

- The most common formats are:
  - ELF(Executable and Linkable Format ) on *nix: Executable and Linkable Format 
  - PE on Windows: Portable Executable
  - Mach-O on OS X


Câu hỏi: Tại sao chúng ta quan tâm đến chi tiết của định dạng tệp PE? 
<br> Trả lời:
  - Biết đc các phần trong file thực thi, biết cách chtrinh chạy
  - Biết cách chèn code vào ntn để thực thi mã virus trong khi làm cho tệp PE trông giống như nó nhìn bình thường. 
  - Phat hiện mã độc, tìm ra các vi-rút được ngụy trang tốt. 
  - Dead space là vị trí hoàn hảo để ẩn vi-rút – vi-rút CIH tự phá vỡ thành các bộ phận và ẩn trong không gian chết giữa các phần PE.

Có thể chèn code madoc vào?
+ các section sẵn có (vd Relocation Information - thường ít đc sdung và khi chen vao sẽ ko gay anh huong nhieu)
+ thêm mới section và chèn code vào.
+ phần alignment giữa các section 

<br>

https://cppdeveloper.com/c-nang-cao/phan-biet-static-libraries-va-shared-libaries/#:~:text=Shared%20Libraries%20c%C3%B2n%20g%E1%BB%8Di%20l%C3%A0,executable%20c%E1%BB%A7a%20application%20l%C3%BAc%20runtime.

https://www.thegioididong.com/hoi-dap/file-dll-la-gi-cach-hoat-dong-nhu-the-nao-tai-sao-thieu-1366289

![image](https://user-images.githubusercontent.com/62002485/175452146-951b003e-1c43-4596-af23-28f9ed8b4380.png)
![image](https://user-images.githubusercontent.com/62002485/175452666-4dcf214f-7eff-40f4-bda1-beba30520b19.png)
![image](https://user-images.githubusercontent.com/62002485/175452841-ec071e28-e230-4c6a-ba6c-9cd3e6ee9b75.png)
![image](https://user-images.githubusercontent.com/62002485/175453685-7a792476-f568-4bf6-b718-0f61731c5fad.png)

<br>

### PE là định dạng riêng của Win32. Hầu hết các file thực thi trên Win32 đều thuộc dạng PE (Trừ các tập tin VxDs và các file DLL(Dynamic Linking Library) 16 bít).
![image](https://user-images.githubusercontent.com/62002485/175454255-277e46e2-898e-4528-8710-1a0f23d922fd.png)

![image](https://user-images.githubusercontent.com/62002485/167558510-1a334d13-f0b5-42c9-9f63-f67d670cedb6.png)

![image](https://user-images.githubusercontent.com/62002485/167558529-1448a3be-9dec-45b8-ae1f-8ed74909c971.png)

- `DOS MZ header` (64byte đầu): Vùng này được dùng  trong trường hợp chương trình chạy trên nền DOS, hệ điều hành DOS nhận biết đây là một file thực thi hợp lệ và sẽ thực thi nội dung trong phần DOS stub. DOS Header là một cấu trúc được định nghĩa trong file windows.inc hoặc winnt.h. Cấu trúc này gồm 19 thành phần, với 1 số trường cần lưu ý như:
  - Trường e_magic trong DOS header chứa Magic number mang giá trị 0x5A4D(“MZ”) viết tắt của ng sáng tạo ra hdh MZ DOS là Mark Zbikowsky, là signature của file PE, Giá trị này đánh dấu một DOS Header hợp lệ và được phép thực thi tiếp.
  - Trường e_lfanew: là một DWORD nằm ở cuối cùng của DOS Header, là trường chứa offset của PE Header so với vị trí đầu file(Con trỏ trỏ tới PE header)

![image](https://user-images.githubusercontent.com/62002485/175491495-e406d676-2598-440d-bfb4-6b7b0bcbd7d5.png)
![image](https://user-images.githubusercontent.com/62002485/175486508-07259123-688f-4021-9225-3cb3e097bc9d.png)

- `PE Header`: bao gồm các thông tin cần thiết cho quá trình loader load file lên bộ nhớ. Cấu trúc này gồm 3 phần được định nghĩa trong windows.inc:

  ![image](https://user-images.githubusercontent.com/62002485/175507844-288af772-1027-46ba-adbf-32c6f87899f1.png)

  - Signature: là 1 DWORD bắt đầu PE Header chứa chữ ký "PE": 50h, 45h (0x4550)
  - FileHeader (20 bytes tiếp theo) với 1 số trường cần lưu ý như:
  
    ![image](https://user-images.githubusercontent.com/62002485/175510397-363347a3-70fc-42bc-9dbd-c7cdadb4a5f6.png)
    - NumberOfSections: chứa số section của file. Nếu muốn thêm/xoá section trong PE file, ta cần thay đổi tương ứng trường này.
    - Machine: Cái file này sẽ đc biên dịch trên kiến trúc máy tính nào (vd AMD, Intel386)

  - OptionalHeader (224 bytes tiếp theo) với 1 số trường cần lưu ý như:
  
     ![image](https://user-images.githubusercontent.com/62002485/175508473-f3571ff4-a5f7-4f07-bbf4-0af7ceda0daa.png)
    - AddressOfEntryPoint (RVA): địa chỉ ảo tương đối của câu lệnh đầu tiên sẽ được thực thi. Nếu muốn chương trình bắt đầu từ một địa chỉ khác (để thực thi câu lệnh với mục đích khác) thì cần thay đổi địa chỉ này về địa chỉ tương đối của câu lệnh muốn thực thi.
    - ImageBase: Địa chỉ mà file PE ưu tiên được nạp lên trên bộ nhớ, cộng thêm RVA sẽ được địa chỉ EntryPoint thực sự.
    - SectionAlignment: Phần liên kết các section trong bộ nhớ, tức là một section luôn luôn được bắt đầu bằng bội số của sectionAlignment. Ví dụ: sectionAlignment là 1000h, section đầu tiên bắt đầu ở vị trí 401000h và kích thước là 10h, section tiếp theo sẽ bắt đầu tại địa chỉ 402000h.
    - FileAlignment: Phần liên kết các section trong file. Tương tự như SectionAlignment nhưng áp dụng với file.
    - SizeOfImage: Toàn bộ kích thước PE file trong bộ nhớ, là tổng của tất cả các headers và sections được liên kết tới SectionAlignment.
    - SizeOfHeaders: Kích thước của tất cả headers và section table, bằng kích thước file trừ đi tổng kích thước của các section trong file.
    - DataDirectory: là một mảng gồm 16 struct IMAGE_DATA_DIRECTORY 
    
    ![image](https://user-images.githubusercontent.com/62002485/175513239-d6cf6577-3024-4600-a871-e1b8a37365ac.png)
    ![image](https://user-images.githubusercontent.com/62002485/175513159-c20730b4-524d-46fe-962f-204948787fdc.png)
    
 -  `Section Table`: gồm một mảng các struct IMAGE_SECTION_HEADER, mỗi phần tử struct chứa thông tin về một section trong PE file. Cấu trúc này được định nghĩa trong file windows.inc như hình dưới đây với 1 số trường cần lưu ý như:
 ![image](https://user-images.githubusercontent.com/62002485/175513523-717673dd-bb32-4867-8e04-59e7d29cb324.png)
    - VirtualSize: Kích thước thật sự của dữ liệu trên section tính theo byte, giá trị này có thể nhỏ hơn kích thước trên ổ đĩa (SizeOfRawData)
    - VirtualAddress: RVA của section, là giá trị để ánh xạ khi section được load lên bộ nhớ
    - SizeOfRawData: Kích thước section data trên ổ đĩa
    - PointerToRawData: là offset từ vị trí đầu file tới section data.
    - Characteristics: đặc tính của section: thực thi, dữ liệu khởi tạo …
    
    ![image](https://user-images.githubusercontent.com/62002485/175547790-3488985e-68f4-4cc1-a018-4894e9f73971.png)

<br>

- `Cấu trúc PE có thể gồm nhiều section`, trong đó tối thiểu cần 2 section: data và code. Một số section thông dụng hay được gặp ở các chương trình:
  - Executable Code Section, có tên là `.text` (MicroSoft) hoc là `CODE` (Borland), chứa code thực thi.
  - Data Sections, có những tên như `.data`, `.bss`, `.rdata`  (MicroSoft) hay `DATA` (Borland): .data (đã khỏi tạo) và .bss chứa dl đọc/ghi và biến toàn cục ; .rdata chứa dl chỉ đọc, đôi khi chứa import/export information.
  - Resources Section, có tên là `.rsrc`chứa tài nguyên được sử dụng bởi tệp thực thi như icons, dialogs, menus, strings,...
  - Export Data Section, có tên là `.edata`, nếu có chứa thông tin export, nếu không có thông tin export chứa trong .rdata
  - Import Data Section. có tên là `.idata`, nếu có chứa thông tin import, nếu không có thông tin import chứa trong .rdata
  - Debug Information Section, có tên là `.debug`
  
  ![image](https://user-images.githubusercontent.com/62002485/175483321-6f5add5e-f68a-4dff-a36d-ce6a9ae54b3b.png)
      
![image](https://user-images.githubusercontent.com/62002485/175547233-e7373200-30e3-411f-a66b-3dc54760189f.png)
![image](https://user-images.githubusercontent.com/62002485/175547267-408026b3-bc95-4a1d-a370-8e19d8b52772.png)

![image](https://user-images.githubusercontent.com/62002485/175547665-33025333-261d-4529-a5bf-c9673cee3120.png)
![image](https://user-images.githubusercontent.com/62002485/175547698-00dc58b1-9851-43c0-91ae-f3375703f16d.png)
![image](https://user-images.githubusercontent.com/62002485/175548376-b03ae7f4-4965-453b-b586-fd9fb509e95d.png)


  
  <br>
  
  
- Infector Pseudocode:
  - Mở tệp để đọc và ghi
  - Trích xuất thông tin tệp PE
  - Tìm code cave có kích thước phù hợp
  - Điều chỉnh shellcode cho ứng dụng mục tiêu
  - Thêm bất kỳ dữ liệu bổ sung nào để mã shellcode hoạt động
  -  Đưa mã shellcode vào ứng dụng
  - Sửa đổi điểm bắt đầu của ứng dụng thành điểm bắt đầu của shellcode

<br>

## Phân loại các loại mã độc phổ biến 
https://viblo.asia/p/phan-loai-ma-doc-hien-nay-LzD5da7zKjY


<br>

  
 ## Virus:
 
- Virus máy tính hay còn gọi là vi rút để chỉ những đoạn mã chương trình được thiết kế để xâm nhập vào máy tính, phá hoại máy tính, dữ liệu nhằm mục đích lấy cắp thông tin => máy chậm, xuat hien quảng cáo, tự bật cam…
 
 ![image](https://user-images.githubusercontent.com/62002485/167562376-75b2d644-69f3-4b79-9b5b-4c056f49467a.png)
 
- Cách phòng virus: Sử dụng tường lửa, cập nhật bản vá lỗi hệ điều hành, phần mềm chống virus, đóng băng hệ thống(Đóng băng ổ cứng là phương pháp chống ghi các dữ liệu lên phân vùng ổ cứng được đóng băng, có nghĩa là sau khi bạn thực hiện đóng băng thành công thì mọi thao tác như cài đặt phần mềm - copy dữ liệu - chỉnh sửa file - tinh chỉnh hệ thống v.v... trên phân vùng được đóng băng sẽ trở về trạng thái như mới (lúc bạn đóng băng) sau khi thực hiện bạn Restart lại máy tính.).

<br>

## File Infection Techniques:

Từ một file ban đầu với các chức năng bình thường, attacker chèn đoạn mã độc virus vào có khả năng tự thực thi, thực hiện 1 số hành động nguy hại đến máy nạn nhân. Khi kích hoạt file bị nhiễm đầu tiên lập tức lan truyền sang file khác. Lây nhiễm mã độc hay cụ thể hơn ở đây là lây nhiễm virus vào 1 tập tin thực thi đó là việc làm kích hoạt 1 bản sao của virus vào một tập tin khác.

<br>

Mục tiêu lây nhiễm tệp cơ bản/ Virus phải đảm bảo:
  - Cho phép thực thi mã vi-rút
  - Tính tàng hình:
    - Bảo tồn kích thước tệp gốc
    - Bảo tồn chức năng tệp gốc - ẩn khỏi người dùng
    - Giả vờ là mã bình thường - ẩn khỏi phần mềm diệt vi rút, máy quét

<br>

Các tệp thực thi (* .EXE, * .COM, * .BAT, v.v.) thường là mục tiêu của vi rút
+ Việc thực thi một tệp bị nhiễm thường gây ra sự sao chép của vi-rút vào các tệp khác
+ Phần mềm chống vi rút thế hệ đầu tiên
phụ thuộc vào việc theo dõi kích thước tệp
    
<br>

Các kỹ thuật lây nhiễm tệp thực thi có thể được phân loại rộng rãi bằng cách `xác định đoạn mã vi-rút được đặt ở đâu, vị trí nào trong tệp`.

### 1. Ghi đè phá hủy tại vào phần đầu file - Beginning of the File with Destructive Overwrite
- Hai phương pháp chính:
  - Thay thế tệp * .exe bằng virus * .exe
  - Chỉ ghi đè phần đầu của một * .exe
- Phát hiện: 
  - File * .exe đã mất hoàn toàn chức năng của nó, vì vậy
  người dùng nhận thấy rằng có điều gì đó không ổn
  - Phần mềm chống vi rút dễ dàng tìm thấy vi rút ngay tại
  đầu của tập tin và kích thước tệp bị thay đổi

- Khử nhiễm bằng cách `khôi phục tệp từ bản sao lưu`

![image](https://user-images.githubusercontent.com/62002485/167559413-95813476-1a10-450b-a94a-ebf1e38c205a.png)

### 2. Ghi đè phá hủy vào vị trí ngẫu nhiên - Random Location in the File with Destructive Overwrite
- Virus ghi đè tại một vị trí ngẫu nhiên trong tệp * .exe.
- Phát hiện: Phần mềm chống vi-rút bây giờ phải tìm kiếm toàn bộ tệp
để tìm thấy nó; luồng chương trình có thể chuyển sang virus trong quá trình thực thi hoặc không hoặc chương tình sẽ bị crash.

- Khử nhiễm bằng cách `khôi phục tệp từ bản sao lưu`

![image](https://user-images.githubusercontent.com/62002485/167559717-0033a718-e58a-48a0-917f-8fe4d406bea3.png)

### 3. Appending Viruses:

- Nối Virus vào cuối File và thay đổi Entry Point hoặc sử dụng lệnh jump được ghi đè trên một vài byte đầu tiên của phần bắt đầu code thực thi để nhảy đến địa chỉ vi-rút. Các hướng dẫn các lưu trong virus, khi virus chấm dứt nó sẽ nhảy về vị trí chương trình ban đầu để các chức năng ứng dụng được giữ nguyên.

- Phổ biến là các tệp .COM của DOS

- Phát hiện: Phần mềm chống vi rút kiểm tra PE file headers, kích thước, entry point, code được thực thi tại entrypoint và dễ dàng phát hiện.

- Khử nhiễm bằng cách xóa section đáng ngờ, khôi phục entrypoint hoặc các byte bị ghi đè bởi lệnh jump. 

![image](https://user-images.githubusercontent.com/62002485/167559977-7dae9308-8abd-403e-bed6-73a1121c4068.png)

<br>

### 4. Cavity Viruses:

- Chèn vi-rút vào cấc không gian trong một tệp chứa đầy các số 0 hoặc khoảng trống ASCII, các lệnh NOP hoặc kí tự NULL byte và thay đổi Entry Point hoặc sử dụng lệnh jump được ghi đè trên một vài byte đầu tiên của phần bắt đầu code thực thi để nhảy đến địa chỉ vi-rút.
- A fractionated cavity virus: vi rút có thể được phân ra thành nhiều mảnh, phân phối vô nhiều khoảng trống khác nhau và kết nối bằng lệnh jump.
- Phát hiện: Phần mềm chống vi rút kiểm tra entry point, code được thực thi tại entrypoint và dễ dàng phát hiện lệnh jump.
![image](https://user-images.githubusercontent.com/62002485/167560344-1aec5ca5-5c2e-4054-b0c8-d783522c32a9.png)

<br>

### 5. Compressing Viruses
- Mã ứng dụng sẽ được nén và mã vi rút cộng với mã trình giải nén sẽ được chèn vào không gian đã tiết kiệm được từ việc nén mã ứng dụng.
- Có thể giữ cho kích thước tệp không thay đổi
- Thậm chí có thể không thay đổi điểm vào!
- Phát hiện: quét hệ thống để hổ trợ thêm cho các chương trình chống vi-rút nền, sử dụng cơ sở dữ liệu các virus code pattern chứa các lệnh đặc trưng để phát hiện ra decompressor code.
- Khử nhiễm bằng cách: file backup hoặc thông thường sẽ có 1 số thuật toán phổ biến, dựa vào signature để phát hiện ra chúng và dùng decompresser tương ứng để giải nén mã ứng dụng, xóa phần code virus và descompresser thay vào phần code vừa mới khôi phục.

![image](https://user-images.githubusercontent.com/62002485/167561211-4e79fac1-45a9-4071-9bec-a59e339674a5.png)

<br><br>

<i> Ba loại EPO virus sau đây sẽ có chung cách phát hiện là: kiểm tra .reloc section để phát hiện các code patterns như saving state, tricky jumps, ...</i>

### 6. Entry-Point Obscuring (EPO) Viruses (Call-Hijacking Viruses)

- Vi-rút Entry-Point Obscuring (EPO) che đi entry point của chính nó bằng cách tìm một lệnh call trong tệp PE nhắm mục tiêu và "chiếm quyền điều khiển" lệnh call đó thay đổi thành một lệnh gọi đến mã vi rút.
- Lưu địa chỉ lệnh gọi ban dầu để sau khi hoàn tất quá trình thực thi virus sẽ nhảy đến.
- Có thể giữ cho kích thước tệp không thay đổi tận dụng phần .reloc (ở định dạng PE cung cấp thông tin được sử dụng nếu chương trình phải được di chuyển lại trong quá trình thực thi, tức là được tải lại ở một điểm tải khác vì hệ thống phải chống phân mảnh bộ nhớ hoặc một số lý do khác)
- Làm thế nào virus có thể tìm thấy một function call? => Kiểm tra binary opcodes để tìm ra các call opcode.

![image](https://user-images.githubusercontent.com/62002485/167561600-beaca631-a555-4e8c-9990-8cfdb6853248.png)
  
 <br>
 
 ### 7. Import Table-replacing EPO Virus
 
- IAT (import address table) là bảng con trỏ đại chỉ hàm ghi lại các API (application program interface) mà ứng dụng người dùng đang sử dụng, các địa chỉ đó sẽ được thay đổi thành địa chỉ Virus, đòng thời sau khi thực thi virus khôi phục lại IAT để API được bảo toàn và duy trì tính ẩn.

 ![image](https://user-images.githubusercontent.com/62002485/167561917-1162a8be-bc1b-4f73-b371-8230f7120ece.png)

<br>

 ### 8. Semi-EPO: Unknown Entry Points:
  
- Định dạng Windows PE có một entry point khác ngoài main entry point  - thread local storage (TLS) entry points 
- Windows loader tìm kiếm các TLS entry point và thực thi nó đầu tiên trước cả main entry point
- Vi rút có thể thay đổi TLS entry point để trỏ tới mã vi rút
- Ví dụ: W32 / Chiton
  


<br>
  
## Worm:
 
- Sâu máy tính là một chương trình máy tính chứa phần mềm độc hại độc lập tự sao chép để lây lan sang các máy tính khác(thường là qua hệ thống thư điện tử). Nó thường sử dụng mạng máy tính để tự lây lan(khác biệt lớn nhất giữa sâu và virus), dựa vào các lỗi bảo mật trên máy tính mục tiêu để truy cập.

- Phân loại dựa vào 4 tiêu chí: 
     - Target Discovery: Phương pháp chọn mục tiêu  
     - Carrier: Cách lan truyền từ mục tiêu này đến mục tiêu khác 
     - Activation: Cơ chế kích hoạt sâu ở máy nạn nhân
     - Payload: Chức năng của sâu

![image](https://user-images.githubusercontent.com/62002485/175766985-30488371-fb75-40fb-a29c-5650a8812f19.png)

### Target Discovery: 
   - Phương pháp chọn mục tiêu  thường là chọn random ip hoặc tuần tự (thường sẽ chọn random vì tính lây lan nhanh rộng hơn và trùng lặp it hơn) 
   - Phương pháp tối ưu hóa:
     - Ưu tiên cho địa chỉ cục bộ: Cùng một hệ điều hành và các ứng dụng trong mạng con
     - Dựa vào thông tin bên thứ 3
       <br> VD: cần tấn công web chính phủ -> search gg để tìm thông tin các ip trang web chính phủ để giới hạn phạm vi ip cần tấn công.
     - Permutation scanning - Quét hoán vị: sử dụng điều phối phân tán để quét hệu quả hơn 
       <br> VD: chia không gian địa chỉ ip ra để tránh sự trùng lặp khi lây nhiễm, một máy chỉ đc phân công lây nhiễm một số máy khác 
     - Bandwidth-limited scanning: Không chờ đợi phản hồi 
     - Sử dụng danh sách mục tiêu được tạo trước vd hit-list
     - Thụ động: chờ các nạn nhân tiềm năng liên hệ với sâu (Ví dụ: trình duyệt chưa được vá) và sau đó lây nhiễm cho khách truy cập trong quá trình tương tác.
    
### Carrier: Cách lan truyền từ mục tiêu này đến mục tiêu khác 
   - Tự vận chuyên (Self-Carried Carrier): Tự gửi nó như một phần của quá trình lây nhiễm. Trong gói tin tấn công có kích hoạt sâu và tạo phiên bản sâu mới, sâu đi qua trong quá tình tấn công.
   - Kênh thứ hai (Second Channel) : Yêu cầu một kênh giao tiếp phụ để kết thúc quá trình lây nhiễm. Trong trường hợp này, sâu chỉ gửi một đoạn mã độc hại nhỏ đến mục tiêu
      - Ví dụ Blaster: kênh chính là RPC; kênh phụ là TFTP
      - VD: Khi lây nhiễm trên 1 máy, ik đến web server ftp tải về lây nhiễm.
   - Được nhúng (Embedded):
      - Tự gửi như một phần của kênh giao tiếp thông thường, thêm vào hoặc thay thế các thông báo bình thường (ví dụ: request web)
      - Thường được giun thụ động sử dụng
      - Tương đối lén lút


### Activation: Cơ chế kích hoạt sâu ở máy nạn nhân:
  - Kích hoạt con người: Loại sâu này sẽ hoạt động nếu người dùng thực hiện bản sao cục bộ của sâu. 
  - Kích hoạt dựa trên hoạt động của con người: Được kích hoạt khi người dùng thực hiện một số hoạt động thường không liên quan đến sâu (Ví dụ: đặt lại máy, đăng nhập)
  - Kích hoạt quy trình theo lịch trình: sâu tự kích hoạt thông qua các quy trình hệ thống đã lên lịch.
  - Tự kích hoạt: Bắt đầu thực thi bằng cách khai thác các lỗ hổng trong các dịch vụ luôn bật và sẵn có

### Payload:
  Mã độc thường Điều khiển từ xa, ddos, mã hóa dữ liệu, ăn cắp thông tin cá nhân. tống tiến.

Ngăn chặn sâu máy tính:
   - Luôn luôn bật tường lửa (Firewall): Hãy kiểm tra tình trạng của Firewall trong Control Panel để đảm bảo luôn ở chế độ bật (On).
   - Hãy luôn cập nhật hệ điều hành thông qua Windows Update và các bản cập nhật bảo mật được Microsoft cung cấp hàng tháng. 
   - Sử dụng các phần mềm phòng chống virus của các hãng có tên tuổi.
   - Không sử dụng các mật khẩu đơn giản, đặc biệt khi bạn truy cập vào các mạng máy tính hay Internet. 
   - Xem xét cẩn thận trước khi mở một file đính kém hay click chuột vào một đường link trong email cũng như cân nhắc trước khi đồng ý nhận một file chuyển qua mạng, 
   nên sử dụng các chức năng Scan virus của hòm thư trước khi mở file.

<br>

## Ransomware:

Ransomware là phần mềm tống tiền, nó là tên gọi chung của 1 dạng phần mềm độc hại - Malware, có "tác dụng" chính là ngăn chặn người dùng truy cập và sử dụng hệ thống máy tính hoặc các file tài liệu của họ (chủ yếu phát hiện trên hệ điều hành Windows). Các biến thể Malware dạng này thường đưa ra các thông điệp cho nạn nhân rằng họ phải nộp 1 khoản tiền kha khá vào tài khoản của hacker nếu muốn lấy lại dữ liệu, thông tin cá nhân hoặc đơn giản nhất là truy cập được vào máy tính của họ. Hầu hết các phần mềm Ransomware đều chiếm quyền và mã hóa toàn bộ thông tin của nạn nhân mà nó tìm được (thường gọi là Cryptolocker), còn một số loại Ransomware khác lại dùng TOR để giấu, ẩn đi các gói dữ liệu C&C trên máy tính (tên khác là CTB Locker).

<br>

## Bonet:

- Botnet là một mạng các máy tính được điều khiển từ xa bởi tin tặc.
Botnet được sử dụng bởi tin tặc để phát tán ransomware sang máy tính xách tay, điện thoại, máy tính bảng, máy tính, v.v... Chúng có thể không bị phát hiện và bạn thậm chí không biết thiết bị của mình có phải là một phần của botnet hay không. 

- Ở đây, một tên tội phạm mạng thực hiện vai trò của một “botmaster” sử dụng virus Trojan để xâm phạm bảo mật của một số máy tính và kết nối chúng vào mạng vì mục đích xấu. Mỗi máy tính trên mạng hoạt động như một “bot”, và được kẻ xấu kiểm soát để lây truyền malware, spam hoặc nội dung độc hại nhằm khởi động cuộc tấn công. Botnet còn được gọi là đội quân zombie vì các máy tính liên quan đang được điều khiển bởi một người khác không phải chủ sở hữu của chúng.

<br>

## Encrypted Viruses:

![image](https://user-images.githubusercontent.com/62002485/167563647-7d7d3b97-eaf8-4418-a7d9-ba14590f414c.png)



## Encrypted Viruses
Mã hóa Virus để tránh Anti-disassemble; tránh bị phát hiện, phân tích; tránh tìm ra code-pattern

### Simple Encryption (XOR)
- Mã hóa và giải mã nhanh chóng, nhưng cũng đủ để chống lại các phát hiện dựa trên patterns
- Encryption: <br>
Code `xor` Address `xor` length_of_code = encrypted_code
- Decrption:
![image](https://user-images.githubusercontent.com/54493212/175565517-d2217826-8714-475a-9bf3-63974c08768b.png)

#### Tóm tắt các bước Simple Encryption
- Encrypt:
    -  Tìm vùng trống (cavity) để chèn Virus
    -  Mã hóa Virus dựa trên địa chỉ của vùng trống và độ dài Virus
    -  Chèn Virus đã mã hóa vào vùng trống đã chọn
- Decrypt:
    - Gán địa chỉ Virus vào ESI
    - Gán độ dài Virus vào ESP
    - Giải mã Virus dựa trên ESI và ESP, sau đó ghi Virus vào vùng trống

#### Sử dụng thanh ghi ESP để lưu độ dài Virus vì:
- Với việc khả năng phát hiện dựa trên patterns bị cản trở bởi mã hóa, nhà nghiên cứu anti-virus muốn đi từng bước trong quá trình giải mã với debugger để xem code được giải mã. Do đó, việc sử dụng thanh ghi ESP làm cản trở hầu hết việc sử dụng debugger
- Tuy nhiên, “mov virus_length, $esp" lại là pattern đặc biệt chống lại chính nó

#### Prevention in the OS: Không cho phép ghi vào code segment
Có thể dễ dàng bypass bằng 2 cách:
1. Giải mã Virus vào bộ đệm trên stack hoặc heap
2. Thay đổi quyền của .text section thành writable

### Difficult Encryption
![image](https://user-images.githubusercontent.com/54493212/175570000-aac59184-c0a9-48fa-bb4c-96307a5e5485.png)
![image](https://user-images.githubusercontent.com/54493212/175570045-9b41b6f7-c507-442d-9fa7-6f3977d1ddd6.png)

### Detecting Encrypted Viruses
Vì Virus được mã hóa nên cách tốt nhất để phát hiện nó chính là phát hiện bộ giải mã của nó

#### Tại sao Data Execution Prevention (DEP) không ngăn chặn được Virus
*DEP là tính năng bảo vệ bộ nhớ cấp hệ thống. DEP cho phép hệ thống đánh dấu một hoặc nhiều trang bộ nhớ là không thể thực thi. Điều này làm cho việc khai thác buffer overflow trở nên khó khăn hơn*

Hệ điều hành cho phép user thay đổi quyền thực thi của trang bộ nhớ. Bộ giải mã của Virus có thể bao gồm một lệnh gọi hệ thống để thay đổi quyền thực thi của các trang bộ nhớ cho stack/heap

#### Khác biệt lớn nhất giữa Virus và buffer overflow code injection
Một phần hoặc toàn bộ code của Virus (ví dụ: trình giải mã) được đưa vào .text section, vì vậy nó luôn có quyền thực thi. Buffer overflow code injection đưa mã nó vào stack/heap, vì vậy DEP có thể ngăn chặn nó thực thi

## Code Obfuscation
- Obfuscation là hành động cố ý làm rối code, tức là mã nguồn hoặc mã máy mà con người khó có thể hiểu.
- Virus sử dụng kỹ thuật obfuscation để đánh bại anti-Virus và chống bị con người phân tích
- Virus encryption là một dạng của obfuscation
- Các dạng obfuscation phức tạp hơn: oligomorphic, polymorphic và metamorphic

### Phân loại
Virus có thể tiến hóa bằng cách tạo ra các đột biến sau mỗi lần nó nhân bản. Dựa trên sự đa dạng của các biến thể nó tạo ra, nó được chia làm 3 loại:
- Oligomorphic Viruses
- Polymorphic Viruses
- Metamorphic Viruses

### Oligomorphic Viruses
- Nó mang theo vài chục bộ giải mã như là một phần của payload. Nó sẽ chọn ngẫu nhiên một bộ trong mỗi lần nó nhân bản
- Whale là loại oligomorphic virus đầu tiên
- Việc mang nhiều bộ giải mã làm kích thước nó lớn hơn

### Polymorphic Virus
Nó xáo trộn thứ tự các lệnh trong bộ giải mã kết hợp với thêm các lệnh rác (junk instructions) vào bộ giải mã trong mỗi lần nó nhân bản

*Junk Instructions: nó có thể là các lệnh NOP hoặc 1 tập lệnh không làm gì cả. Nó được thêm vào với mục đích gây khó khăn cho nhà phân tích*
![image](https://user-images.githubusercontent.com/54493212/175754071-e3de1bfb-255c-448c-bf08-a3965fc4e59f.png)
![image](https://user-images.githubusercontent.com/54493212/175754076-5c976617-791d-471a-a659-cf1e794271e9.png)

![image](https://user-images.githubusercontent.com/54493212/175754113-b3a5593b-76fc-41f9-b679-92e1fca1d23b.png)
![image](https://user-images.githubusercontent.com/54493212/175754156-156c2e63-c93b-4c46-92fc-edeb41715730.png)

#### The 1260 Virus: Polymorphism
![image](https://user-images.githubusercontent.com/54493212/175755077-012a724d-6e4b-4517-9e64-731c5751f960.png)
- Sắp xếp lại các lệnh trong nhóm
- Chọn vị trí đặt lệnh rác
- Thay đổi các lệnh rác

Điểm mạnh của Virus 1260
- Bộ giải mã 1260 có ba nhóm lệnh, lần lượt là 3, 2 và 2 lệnh
- Các nhóm được định nghĩa là các chuỗi lệnh có thể được hoán vị mà không làm thay đổi kết quả giải mã
- Vì vậy, việc sắp xếp lại thứ tự trong các nhóm tạo ra 3! * 2! * 2! = 24 biến thể
- Điều này mang lại hệ số nhân là 24 để áp dụng cho tất cả các biến thể có thể được tạo ra bằng cách sử dụng các lệnh rác

#### Polymorphic Mutation Engines
The Dark Avenger Mutation Engine còn được gọi là MtE, là Polymorphic Mutation Engines đầu tiên

### Metamorphic Viruses
- Metamorphic Virus đã được định nghĩa là một loại body-polymorphic virus; nghĩa là, các kỹ thuật polymorphic được sử dụng để biến đổi virus body, không chỉ đơn thuần ở bộ giải mã
- Metamorphism làm virus body trở thành mục tiêu di động để phân tích khi nó lan truyền khắp thế giới 

#### Các biển thể Metamorphic Viruses
- Thay đổi thanh ghi
![image](https://user-images.githubusercontent.com/54493212/175755961-d943a71e-6c24-4753-94a6-4d8d5763171c.png)
![image](https://user-images.githubusercontent.com/54493212/175755994-30169bf6-fcea-41eb-b579-65dfebad1bd4.png)
- Instruction Permutation
![image](https://user-images.githubusercontent.com/54493212/175755980-acd9ea0e-b490-4bc5-8f66-b87fc99b77aa.png)

#### Metamorphic Engine
![image](https://user-images.githubusercontent.com/54493212/175756102-8985cf1c-2c50-44f5-b051-04a4a8bd5f9a.png)
![image](https://user-images.githubusercontent.com/54493212/175756115-06079332-2339-40d2-a0e3-78f3e36e2382.png)

#### Điểm yếu chung của Metamorphic Viruses
- Để gây đột biến mã của chúng từ thế hệ này sang thế hệ khác, Metamorphic Viruses phải phân tích lại mã đột biến mà nó tạo ra. Do đó, nó cần sử dụng một số phép hoán vị code, hoặc phát triển các thuật toán đặc biệt để giúp nó phát hiện ra sự xáo trộn của chính nó
- Một khi các pattern này được các nhà nghiên cứu anti-Virus tìm ra, Metamorphic Viruses có thể bị phát hiện

## Anti Dynamic Analysis
### Anti-Debugging
- Anti-debugging là một kĩ thuật chống phân tích phổ biến được mã độc sử dụng để nhận ra nó có đang bị kiểm soát bởi trình debugger hoặc ngăn chặn việc debug
- Khi phần mềm độc hại nhận ra nó đang chạy trong debugger, nó có thể thay đổi đường dẫn thực thi code bình thường hoặc sửa đổi code để gây ra lỗi
- Các nhà phân tích cố gắng hiểu nó và thêm thời gian cũng như chi phí bổ sung cho các nỗ lực của họ

#### Using the Windows API
![image](https://user-images.githubusercontent.com/54493212/175761834-46001e32-7712-4bd4-b849-190304aac880.png)
![image](https://user-images.githubusercontent.com/54493212/175761938-d03a77cc-c0bf-4f73-a251-5e95e89c6ad1.png)
![image](https://user-images.githubusercontent.com/54493212/175762840-b000f374-8776-45cc-94ec-d3a4ce16f001.png)
![image](https://user-images.githubusercontent.com/54493212/175763321-9b089767-bea9-424b-b3e8-46c7fcd7a028.png)

#### Manually Checking Structures
![image](https://user-images.githubusercontent.com/54493212/175763440-ccd81341-7d2a-4799-b052-1acb2181c1dc.png)
![image](https://user-images.githubusercontent.com/54493212/175763452-5d8949a0-7876-4034-812d-911d920815c1.png)
![image](https://user-images.githubusercontent.com/54493212/175763752-305f0693-1985-484b-8012-2774a26936d5.png)
![image](https://user-images.githubusercontent.com/54493212/175763783-668179c6-f3f1-4b51-a7a3-6fd1d5343972.png)

#### Checking for System Residue
![image](https://user-images.githubusercontent.com/54493212/175763962-9d1bbb29-2be0-414a-899c-3cb5db783081.png)
![image](https://user-images.githubusercontent.com/54493212/175763967-6fa03139-0aad-4b2b-8e0a-3d46656c2968.png)

#### Identifying Debugger Behavior
![image](https://user-images.githubusercontent.com/54493212/175764006-4c1dcf66-116b-439f-bc7b-4c95828b4c8a.png)

#### Interfering with Debugger Functionality
![image](https://user-images.githubusercontent.com/54493212/175764228-bc905973-8086-4e05-95df-7c3b1b0028ca.png)

### Anti-Virtual Machine (anti-VM)
![image](https://user-images.githubusercontent.com/54493212/175764398-90cc3761-88d1-4a24-b584-b5b13dc1aebd.png)
![image](https://user-images.githubusercontent.com/54493212/175764429-3860347d-0cac-4c83-85c7-486959e0206b.png)
![image](https://user-images.githubusercontent.com/54493212/175764442-7fb0b0fc-0e12-425f-9b41-33a1a58b7b38.png)

### Packers and Unpacking
- Các tệp thực thi không được đóng gói được tải bởi Hệ điều hành
- Với các chương trình được đóng gói, hệ điều hành sẽ tải unpacking stub, sau đó unpacking stub sẽ tải chương trình gốc
- Entry point trỏ tới unpacking stub thay vì mã gốc
- Unpacking stub bao gồm 3 bước:
    -  Giải nén tệp thực thi ban đầu vào bộ nhớ
    -  Giải quyết tất cả các import 
    -  Đi đến original entry point (EOP) và thực thi nó

#### Unpacking stub
![image](https://user-images.githubusercontent.com/54493212/175766753-e9a49cba-0f20-43db-8592-dca3146ac10f.png)
![image](https://user-images.githubusercontent.com/54493212/175766760-4b184017-c4c0-466d-a9cf-c0c515accb1f.png)
![image](https://user-images.githubusercontent.com/54493212/175766784-a98cb047-f9a7-4a2a-89af-10c69dcb964c.png)
![image](https://user-images.githubusercontent.com/54493212/175766814-f850bc03-6109-4fcb-a8a8-4db0592e9c34.png)
![image](https://user-images.githubusercontent.com/54493212/175766824-65a6ef91-5fbb-4373-a8be-7fb15b76b32e.png)

#### Dấu hiệu của chương trình được đóng gói
- Chương trình chỉ có vài imports, cụ thể là chỉ có LoadLibrary và GetProcAddress
- Trên IDA Pro, chỉ thấy khối lượng nhỏ code
- Trên OllyDbg có cảnh báo chương trình có thể được đóng gói
- Chương trình có các section chỉ ra dấu hiệu được đóng gói (VD: UPX0)
- Chương trình có kích thước bất thường (VD: Chương trình có Size of Raw Data = 0 và Virtual Size != 0)

#### Unpacking Options
- Automated static unpacking
- Automated dynamic unpacking
- Manual dynamic

![image](https://user-images.githubusercontent.com/54493212/175767187-5dad5562-4422-47ba-9a3d-6cd12e3833d9.png)
![image](https://user-images.githubusercontent.com/54493212/175767210-ca75195e-4d92-4b75-8e33-65048d7d6215.png)

## Botnet
- Bots: Các chương trình tự thực hiện nhiệm vụ
- Botnets: Tập hợp các máy tính bị xâm nhập và được điểu khiển bởi hacker

### Các khía cạnh quan trọng của Botnet
- Command and Control Channel
- Sự lan truyền
- Hoạt động ngầm

#### Command and Control Technologies
- IRC
- HTTP
- P2P

#### HTTP Command and Control Channel
- Máy bị xâm nhập gọi một tập lệnh PHP trên một máy chủ web cụ thể
- Máy chủ web lấy thông tin về các máy bị xâm nhập
- Các máy được cấu hình kết nối với trang web theo thời gian để nhận các lệnh

#### P2P C&C
Các máy bị xâm nhập nhận lệnh bằng cách sử dụng các giao thức P2P như Gnutella như trong Phatbot

### Botnet Architecture
- Tập trung
- Phi tập trung

### Client Side Attack
- Cross Site Scripting-XSS
- drive-by downloads
- Mass-mailing virus 

### Server Side Attack
Tấn công từ xa vào các dịch vụ nằm trong máy chủ

### Hoạt động ngầm
- DDOS
- Tống tiền
- Đánh cắp thông tin cá nhân
- Spam
- Phising
- Click Fraud
- Phân phối malware

### Quan điểm phân tích
- Botnet Control Mechanisms
- Host Control Mechanisms
- Propagation Mechanisms
- Target Exploits and Attack Mechanisms
- Malware Delivery Mechanisms

### Botnet Control Mechanisms
- Ngôn ngữ lệnh và các giao thức điều khiển được sử dụng để vận hành các mạng botnet từ xa sau khi các hệ thống đích đã bị xâm nhập
- Tất cả các bot được phân tích đều dựa trên C&C trên IRC
- Việc gián đoạn giao tiếp có thể khiến botnet trở nên vô dụng
- Các nhà mạng có thể nghi ngờ các lệnh cụ thể trong lưu lượng IRC và xác định các hệ thống bị xâm phạm

### Host Control Mechanisms
Các cơ chế được bot sử dụng để thao túng máy chủ nạn nhân khi nó đã bị xâm phạm
- Củng cố hệ thống cục bộ chống lại các cuộc tấn công độc hại ?????
- Tắt phần mềm chống vi-rút
- Thu thập thông tin nhạy cảm

### Propagation Mechanisms
Các cơ chế mà bot sử dụng để tìm kiếm hệ thống máy chủ mới
Quét theo chiều ngang hoặc dọc truyền thống:
- Ngang là một port trên một dải địa chỉ
- Dọc là một dải port trên một địa chỉ

### Target Exploits and Attack Mechanisms
Các phương pháp cụ thể để tấn công các lỗ hổng đã biết trên các hệ thống mục tiêu

### Malware Delivery Mechanisms
Packers và shell encoders được sử dụng để nén và làm xáo trộn mã
- Khai thác lỗ hổng bảo mật và mở shell trên máy chủ từ xa
- Encoded malware binary được vận chuyển bởi HTTP hoặc FTP
- Enables encoder to be used across exploits, streamlining codebase and potentially diversifying the resulting bit streams

### Hoạt động của Botnet 
![image](https://user-images.githubusercontent.com/54493212/175768778-77ad2efc-57f5-47a7-92a3-c0c81d4d4efa.png)

### Theo dõi và phát hiện botnet
- Signature: alert tcp any any -> any any (msg:"Agobot/Phatbot Infection Successful"; flow:established; content:"221”)
- Phân tích lưu lượng
- Honeynet

### Measuring Botnets
Ba giai đoạn khác nhau
- Malware Collection: Thu thập càng nhiều bot càng tốt
- Phân tích thông qua kiểm thử hộp xám: Trích xuất các tính năng đáng ngờ
- Longitudinal tracking: Theo dõi cách bot lây lan và cách tiếp cận của nó



